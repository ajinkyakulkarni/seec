root:table {
  // Describes errors that can occur in the library.
  errors:table {
    ExplainNullDecl:string { "Decl is null." }

    CreateDeclUnknownDeclKind:string { "Decl has unknown kind." }


    ExplainNullStmt:string { "Stmt is null." }

    CreateStmtNoStmtClass:string { "Stmt has no class." }

    CreateStmtUnknownStmtClass:string { "Stmt has unknown class." }


    DescriptionNotFound:string { "Couldn't find description for key {key}." }

    DescriptionFormatFailed:string { "Couldn't format description with key {key}." }

    DescriptionIndexFailed:string { "Couldn't index description with key {key}." }
  }

  // Contains textual descriptions of clang AST nodes.
  descriptions:table {

    //-------------------
    // Decl descriptions.
    //-------------------

    // Function description.
    //
    Function:string { "This is a function declaration." }


    //-------------------
    // Stmt descriptions.
    //-------------------
    
    // ArraySubscriptExpr description.
    // Inputs:
    //   is_lhs_base
    //   base_type_general
    //   idx_type_general
    // Outputs:
    //   base
    //   idx
    //
    ArraySubscriptExpr:string {
      "{is_lhs_base, select,"

      " true {{base_type_general, select,"
             " Pointer {This is an array subscript expression. It consists of a @[base]base@[], which is a pointer, and an @[idx]index@[], which is an integer. The result of this expression is the object that is “@[idx]index@[]” positions after the object that the @[base]base@[] points to. That is, if the @[idx]index@[] is zero, the result of this expression will be the object that @[base]base@[] points to; if the @[idx]index@[] is one, the result of this expression will be object immediately following the object that @[base]base@[] points to; and so on.}"

             " other {This is an array subscript expression. It consists of a @[base]base@[], which is an array, and an @[idx]index@[], which is an integer. The result of this expression is the element in the array that is “@[idx]index@[]” positions after the first element in the array. That is, if the @[idx]index@[] is zero, the result of this expression will be the first element in the array; if the @[idx]index@[] is one, the result of this expression will be the second element in the array; and so on.}}}"

      " false {{base_type_general, select,"
             " Pointer {This is an array subscript expression. It consists of a @[base]base@[], which is a pointer, and an @[idx]index@[], which is an integer. Typically the @[base]base@[] is on the left hand side, and the @[idx]index@[] is in square brackets, but this particular expression is using the opposite form. The result of this expression is the object that is “@[idx]index@[]” positions after the object that the @[base]base@[] points to. That is, if the @[idx]index@[] is zero, the result of this expression will be the object that @[base]base@[] points to; if the @[idx]index@[] is one, the result of this expression will be object immediately following the object that @[base]base@[] points to; and so on.}"

             " other {This is an array subscript expression. It consists of a @[base]base@[], which is an array, and an @[idx]index@[], which is an integer. Typically the @[base]base@[] is on the left hand side, and the @[idx]index@[] is in square brackets, but this particular expression is using the opposite form. The result of this expression is the element in the array that is “@[idx]index@[]” positions after the first element in the array. That is, if the @[idx]index@[] is zero, the result of this expression will be the first element in the array; if the @[idx]index@[] is one, the result of this expression will be the second element in the array; and so on.}}}"

      " other {Unexpected value for is_lhs_base.}}"
    }

    // BreakStmt description.
    // Inputs:
    // Outputs:
    //
    BreakStmt:string { "This is a break statement. It ends the execution of the first loop (“do”, “for”, or “while”) or “switch” statement that encloses it." }

    // BinaryOperator description.
    // Inputs:
    //   opcode
    //   type_general
    // Value inputs:
    //   [has_]rtv_of_this
    //   [has_]rtv_of_lhs
    //   [has_]rtv_of_rhs
    // Outputs:
    //   lhs
    //   rhs
    //
    BinaryOperator:string {
      "{opcode, select,"

      " BO_Mul {{type_general, select,"
               " Integer {This is the Multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}"
               " Floating {This is the Multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}"
               " other {This is the Multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}}}"

      " BO_Div {{type_general, select,"
               " Integer {This is the Division operator. In this case the division operator is being used to divide integers, so the result of the expression will be the result of dividing the value of @[lhs]left hand side@[] by the value of the @[rhs]right hand side@[], with any fractional part discarded. If you wish to find the value including the fractional part, then one or both of the values should be a floating point type.}"
               " Floating {This is the Division operator. The result of this expression is the value of the @[lhs]left hand side@[] divided by the value of the @[rhs]right hand side@[].}"
               " other {This is the Division operator. The result of this expression is the value of the @[lhs]left hand side@[] divided by the value of the @[rhs]right hand side@[].}}}"

      " BO_Rem {This is the Modulo operator. It returns the remainder of dividing the @[lhs]left hand side@[] by the @[rhs]right hand side@[]. Since C99, the result is defined to have the same sign as the dividend.}"

      " BO_Add {This is the Addition operator. It returns the addition of the value of the @[lhs]left hand side@[] and the value of the @[rhs]right hand side@[].{has_rtv_of_lhs, select, true { The value of the left hand side is “{rtv_of_lhs}”.} other {}}{has_rtv_of_rhs, select, true { The value of the right hand side is “{rtv_of_rhs}”.} other {}}}"

      " BO_Sub {This is the Subtraction operator. It returns the result of subtracting the value of the @[rhs]right hand side@[] from the value of the @[lhs]left hand side@[].}"

      " BO_Shl {This is the “Bitwise Left Shift” operator.}"

      " BO_Shr {This is the “Bitwise Right Shift” operator.}"

      " BO_LT {This is the “Less Than” operator. If the value of the @[lhs]left hand side@[] is less than the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_GT {This is the “Greater Than” operator. If the value of the @[lhs]left hand side@[] is greater than the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_LE {This is the “Less Than Or Equal To” operator. If the value of the @[lhs]left hand side@[] is less than or equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_GE {This is the “Greater Than Or Equal To” operator. If the value of the @[lhs]left hand side@[] is greater than or equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_EQ {This is the “Equal To” operator. If the value of the @[lhs]left hand side@[] is equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_NE {This is the “Not Equal To” operator. If the value of the @[lhs]left hand side@[] is not equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_And {This is the “Bitwise AND” operator. If you wish to use the “Logical AND” operator, it is &&.}"

      " BO_Xor {This is the “Bitwise XOR” operator. If you wish to perform exponentiation use the function “pow”.}"

      " BO_Or {This is the “Bitwise OR” operator. If you wish to use the “Logical OR” operator, it is ||.}"

      " BO_LAnd {This is the “Logical AND” operator. If both the value of the @[lhs]left hand side@[] and the value of the @[rhs]right hand side@[] are non-zero, then it returns 1, otherwise it returns 0. In C the Logical AND operator has “short-circuit evaluation”, which means that the @[lhs]left hand side@[] is always evaluated first, and if it evaluates to a zero value then the @[rhs]right hand side@[] is not evaluated, because the result of the operator is already known to be 0.}"

      " BO_LOr {This is the “Logical OR” operator. If either the value of the @[lhs]left hand side@[] or the value of the @[rhs]right hand side@[] are non-zero, then it returns 1, otherwise it returns 0. In C the Logical OR operator has “short-circuit evaluation”, which means that the @[lhs]left hand side@[] is always evaluated first, and if it evaluates to a non-zero value then the @[rhs]right hand side@[] is not evaluated, because the result of the operator is already known to be 1.}"

      " BO_Assign {This is the Assignment operator. It sets the value of the @[lhs]left hand side@[] to the value of the @[rhs]right hand side@[].}"

      " BO_MulAssign {This is the “Multiplication Assignment” operator. It multiplies the value of the @[lhs]left hand side@[] with the value of the @[rhs]right hand side@[], then assigns the resulting value to the @[lhs]left hand side@[].}"

      " BO_DivAssign {This is the “Division Assignment” operator. It divides the value of the @[lhs]left hand side@[] by the value of the @[rhs]right hand side@[], then assigns the resulting value to the @[lhs]left hand side@[].}"

      " BO_RemAssign {This is the “Modulo Assignment” operator. It finds the remainder of dividing the value of the @[lhs]left hand side@[] by the value of the @[rhs]right hand side@[], then assigns the value of the remainder to the @[lhs]left hand side@[].}"

      " BO_AddAssign {This is the “Addition Assignment” operator. It adds the value of the @[lhs]left hand side@[] and the value of the @[rhs]right hand side@[], then assigns the resulting value to the @[lhs]left hand side@[].}"

      " BO_SubAssign {This is the “Subtraction Assignment” operator. It subtracts the value of the @[rhs]right hand side@[] from the value of the @[lhs]left hand side@[], then assigns the resulting value to the @[lhs]left hand side@[].}"

      " BO_ShlAssign {This is the “Bitwise Left Shift Assignment” operator.}"

      " BO_ShrAssign {This is the “Bitwise Right Shift Assignment” operator.}"

      " BO_AndAssign {This is the “Bitwise AND Assignment” operator.}"

      " BO_XorAssign {This is the “Bitwise XOR Assignment” operator.}"

      " BO_OrAssign {This is the “Bitwise OR Assignment” operator.}"

      " BO_Comma {This is the Comma operator. The Comma operator evaluates the @[lhs]left hand side@[] expression and discards the result, then evaluates the @[rhs]right hand side@[] expression and returns the result.}"

      " other {This is the binary operator {opcode}. It has a @[lhs]left hand side@[] and a @[rhs]right hand side@[]. The general type of this expression is {type_general}}}"
    }

    // CallExpr description.
    // Inputs:
    //   has_callee
    //   has_callee_decl
    //   has_direct_callee
    //   num_args
    //   general_type
    // Value inputs:
    //   
    // Outputs:
    //   callee_expr
    // Outputs (when has_direct_callee == "true"):
    //   direct_callee_decl
    //
    CallExpr:string {
      "{has_direct_callee, select,"
      //
      // Direct callee.
      //
      " true {{num_args, plural,"
             //
             // Direct callee with no arguments.
             //
             " =0 {{general_type, select,"
                  " Void {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there are no arguments, so the parenthesis are empty. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[], and continue until the function either reaches a return statement, or reaches the end of the function's body. In this case the function has a void return type, so no value is produced by this call expression.}"

                  " other {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there are no arguments, so the parenthesis are empty. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[], and continue until the function reaches a return statement. The value provided to this return statement will be passed back from the function, and become the value produced by this call expression.}}}"

             //
             // Direct callee with one argument.
             //
             " =1 {{general_type, select,"
                  " Void {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there is only one argument. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[]. The value produced by the argument expression will be passed to the @[direct_callee_decl]called function@[], becoming the value of the function's parameter. Execution will continue until the function either reaches a return statement, or reaches the end of the function's body. In this case the function has a void return type, so no value is produced by this call expression.}"

                  " other {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there is only one argument. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[]. The value produced by the argument expression will be passed to the @[direct_callee_decl]called function@[], becoming the value of the function's parameter. Execution will continue until the function reaches a return statement. The value provided to this return statement will be passed back from the function, and become the value produced by this call expression.}}}"

             //
             // Direct callee with N>1 arguments.
             //
             " other {{general_type, select,"
                     " Void {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there are {num_args} arguments. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[]. The values produced by the argument expressions will be passed to the @[direct_callee_decl]called function@[] in order, becoming the value of the function's parameters. Execution will continue until the function either reaches a return statement, or reaches the end of the function's body. In this case the function has a void return type, so no value is produced by this call expression.}"

                     " other {This is a function call expression. It is formed by the @[callee_expr]name of a function@[], followed by a parenthesised list of argument expressions. In this case there are {num_args} arguments. To evaluate the result of this function call, execution will enter the @[direct_callee_decl]called function@[]. The values produced by the argument expressions will be passed to the @[direct_callee_decl]called function@[] in order, becoming the value of the function's parameters. Execution will continue until the function reaches a return statement. The value provided to this return statement will be passed back from the function, and become the value produced by this call expression.}}}}}"

      //
      // Indirect call.
      //
      " false {{num_args, plural,"
              //
              // Indirect call with no arguments.
              //
              " =0 {}"
              " =1 {}"
              " other {}}}"

      " other {Unexpected value for has_direct_callee.}}"
    }

    // CompoundStmt description.
    // Inputs:
    // Outputs:
    //
    CompoundStmt:string { "This is a compound statement. It consists of a group of statements. Each of these statements will be evaluated in order." }

    // ContinueStmt description.
    // Inputs:
    // Outputs:
    //
    ContinueStmt:string { "This is a continue statement. It ends the execution of the current iteration of the first loop (“do”, “for”, or “while”) that encloses it. If this is a “do” or “while” loop, then execution continues by evaluating the condition expression of the loop. If this is a “for” loop, then execution continues by evaluating the increment expression, followed by the condition expression." }

    // DeclRefExpr description.
    // Inputs:
    //   name = string
    //   kind_general = "Var" | "Function" | "EnumConstant" | "Other"
    // Inputs (when kind_general == "Var"):
    //   has_definition
    // Inputs (when kind_general == "Function"):
    //   has_body
    // Inputs (when kind_general == "EnumConstant"):
    //   init_val
    // Outputs:
    //   decl
    //   found_decl
    //
    DeclRefExpr:string {
      "{kind_general, select,"
      " Var {This refers to the variable @[decl]“{name}”@[].}"
      " Function {This refers to the function @[decl]“{name}”@[].}"
      " EnumConstant {This refers to the enum constant @[decl]“{name}”@[].}"
      " other {This is a reference to the declaration @[decl]“{name}”@[].}}"
    }

    // DeclStmt description.
    // Inputs:
    //   is_single_decl
    // Outputs:
    //   single_decl
    //
    DeclStmt:string {
      "{is_single_decl, select,"
      " true {This is a statement containing a @[single_decl]single declaration@[].}"
      " false {This is a statement containing a group of declarations.}"
      " other {Bad value for is_single_decl.}}"
    }

    // DoStmt description.
    // Inputs:
    // Value inputs:
    //   [has_]rtv_of_this
    //   [has_]rtv_of_cond
    // Outputs:
    //   cond
    //   body
    //
    DoStmt:string { "This is a “do while” loop. It has a @[body]body@[] and a @[cond]condition@[]. Initially, the @[body]body@[] is evaluated. After the @[body]body@[] is evaluated, the @[cond]condition@[] is evaluated. If the result of the @[cond]condition@[] is considered to be true (non-zero), then execution transfers to the beginning of the loop: the @[body]body@[] is evaluated again, followed by the @[cond]condition@[]." }

    // IfStmt description.
    // Inputs:
    //   has_condition_variable
    //   has_else
    // Value inputs:
    //   [has_]rtv_of_this
    //   [has_]rtv_of_cond
    // Outputs:
    //   cond
    //   then
    //   else
    //
    IfStmt:string {
      "This is an if statement. It consists of a @[cond]condition@[], a @[then]body statement@[], and an optional @[else]else statement@[]. If the @[cond]condition@[] evaluates to a value that is considered to be true, then the @[then]body statement@[] will be executed, otherwise the @[else]else statement@[] will be executed (if it exists)."
      "{has_else, select, true { This if statement has an else branch.} false { This if statement does not have an else branch.} other { Very sad.}}"
    }

    // ReturnStmt description.
    // Inputs:
    //   has_return_value
    // Value inputs:
    //   [has_]rtv_of_this
    //   [has_]rtv_of_return_value
    // Outputs:
    //   current_function
    //   called_from
    //   return_value
    //
    ReturnStmt:string {
      "This is a return statement. It ends the execution of the @[current_function]current function@[], returning control to the @[called_from]caller of this function@[]. If a value is returned, then it will be received at the site where this function was called. If this is the main function, then the program will end."
      "{has_return_value, select, true { This return statement @[return_value]returns a value@[].} false { This return statement does not return a value.} other { Very sad.}}"
      "{has_rtv_of_return_value, select, true { This return statement is returning the value “{rtv_of_return_value}”. } other {}}"
    }

  }
}
