root:table {
  //
  // Describes errors that can occur in the library.
  //
  errors:table {
    ExplainNullDecl:string { "Decl is null." }

    CreateDeclUnknownDeclKind:string { "Decl has unknown kind." }


    ExplainNullStmt:string { "Stmt is null." }

    CreateStmtNoStmtClass:string { "Stmt has no class." }

    CreateStmtUnknownStmtClass:string { "Stmt has unknown class." }


    DescriptionNotFound:string { "Couldn't find description for key {key}." }

    DescriptionFormatFailed:string { "Couldn't format description with key {key}." }

    DescriptionIndexFailed:string { "Couldn't index description with key {key}." }
  }

  //
  // Contains textual descriptions of clang AST nodes.
  //
  descriptions:table {

    //--------------------------------------------------------------------------
    // Decl descriptions.
    //--------------------------------------------------------------------------

    // LabelDecl
    // Inputs:
    //   [String] name
    //   [String] qualified_name
    //   [Bool]   has_linkage
    //   [Bool]   is_hidden
    //   [Bool]   is_cxx_class_member
    //   [Bool]   is_cxx_instance_member
    //   [Bool]   is_gnu_local
    // Outputs:
    //   [Decl] underlying_decl
    //   [Stmt] stmt
    //
    Label:string {
      "This is a label named “{name}”. If execution reaches this label, or jumps to this label from another location, then the next evaluated statement will be @[stmt]the statement immediately following this label@[]."
    }

    // TypeDecl
    // Inputs:
    //   [String] name
    //   [String] qualified_name
    //   [Bool]   has_linkage
    //   [Bool]   is_hidden
    //   [Bool]   is_cxx_class_member
    //   [Bool]   is_cxx_instance_member
    //   [Type]   type_for_decl
    // Outputs:
    //   [Decl] underlying_decl
    //
    Type:string {
      "This declares a type named “{name}”, with type “{type_for_decl}”."
    }

    // TypedefNameDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [Type]     type_for_decl
    //   [QualType] underlying_type
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] canonical_decl
    //
    Typedef:string {
      "This is a typedef that associates the name “{name}” with the type “{underlying_type}”."
    }

    // EnumDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [Bool]     is_this_declaration_a_definition
    //   [Bool]     is_complete_definition
    //   [Bool]     is_embedded_in_declarator
    //   [Bool]     is_free_standing
    //   [Bool]     is_dependent_type
    //   [Bool]     is_struct
    //   [Bool]     is_interface
    //   [Bool]     is_class
    //   [Bool]     is_union
    //   [Bool]     is_enum
    //   [QualType] promotion_type
    //   [QualType] integer_type
    //   [Bool]     is_scoped
    //   [Bool]     is_fixed
    //   [Bool]     is_complete
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] canonical_decl
    //   [Decl] definition
    //
    Enum:string {
      "{is_complete_definition, select,"

      " true {This declares and defines an enum named “{name}”.}"

      " other {This declares an enum named “{name}”. The enum is completed by a @[definition]definition@[].}}"

      "\n\nRead more about enums in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture24/01.html]Lecture 24@[]."
    }

    // RecordDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [Bool]     is_this_declaration_a_definition
    //   [Bool]     is_complete_definition
    //   [Bool]     is_embedded_in_declarator
    //   [Bool]     is_free_standing
    //   [Bool]     is_dependent_type
    //   [Bool]     is_struct
    //   [Bool]     is_interface
    //   [Bool]     is_class
    //   [Bool]     is_union
    //   [Bool]     is_enum
    //   [Bool]     has_flexible_array_member
    //   [Bool]     is_anonymous_struct_or_union
    //   [Bool]     has_object_member
    //   [Bool]     has_volatile_member
    //   [Bool]     is_injected_class_name
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] canonical_decl
    //   [Decl] definition
    //
    Record:string {
      "{is_struct, select,"
      " true {This declares a structure type named “{name}”.\n\nRead more about structures in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture22/01.html]Lecture 22@[].}"
      " other {"
        "{is_union, select,"
        " true {This declares a union type named “{name}”.}"
        " other {"
          "This declares a record type named “{name}”."
        "}}"
      "}}"
    }

    // EnumConstantDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    // Values:
    //   rtv_of_init_expr
    // Outputs:
    //   [Decl] underlying_decl
    //   [Expr] init_expr
    //
    EnumConstant:string {
      "This is an enum constant named “{name}”.\n\nRead more about enums in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture24/01.html]Lecture 24@[]." 
    }

    // IndirectFieldDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] anon_field
    //   [Decl] var_decl
    //
    IndirectField:string {
      "This represents the @[anon_field]field named “{name}”@[], included in the parent scope by an anonymous union or struct."
    }

    // FunctionDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    //   [QualType] type_source_info_type
    // Outputs:
    //   [Decl] underlying_decl
    //
    Function:string {
      "This declares a function named “{name}”."
    }

    // FieldDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    //   [QualType] type_source_info_type
    //   [Int]      field_index
    //   [Bool]     is_mutable
    //   [Bool]     is_bit_field
    //   [Bool]     is_unnamed_bitfield
    //   [Bool]     has_in_class_initializer
    // Values:
    //   rtv_of_bit_width
    // Outputs:
    //   [Decl] underlying_decl
    //   [Expr] bit_width
    //   [Expr] in_class_initializer
    //   [Decl] parent
    //
    Field:string {
      "This declares a field named “{name}”, with type “{type}”, in @[parent]the enclosing record type@[]."
    }

    // VarDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    //   [QualType] type_source_info_type
    //   [Bool]     has_local_storage
    //   [Bool]     is_static_local
    //   [Bool]     has_external_storage
    //   [Bool]     has_global_storage
    //   [Bool]     is_extern_C
    //   [Bool]     is_local_var_decl
    //   [Bool]     is_function_or_method_var_decl
    //   [Bool]     is_static_data_member
    //   [Bool]     is_tentative_definition_now
    //   [Bool]     is_out_of_line
    //   [Bool]     is_file_var_decl
    //   [Bool]     is_direct_init
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] canonical_decl
    //   [Decl] definition
    //   [Expr] any_initializer
    //   [Expr] init
    //
    Var:string {
      "This declares a variable named “{name}”, with type “{type}”."

      "{is_static_local, select,"
      " true {\n\nThis is a local static variable. Read more about local static variables in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture24/10.html]Lecture 24@[].}"
      " false {}"
      " other {}}"
    }

    // ParmVarDecl
    // Inputs:
    //   [String]   name
    //   [String]   qualified_name
    //   [Bool]     has_linkage
    //   [Bool]     is_hidden
    //   [Bool]     is_cxx_class_member
    //   [Bool]     is_cxx_instance_member
    //   [QualType] type
    //   [Bool]     is_weak
    //   [QualType] type_source_info_type
    //   [Bool]     has_local_storage
    //   [Bool]     is_static_local
    //   [Bool]     has_external_storage
    //   [Bool]     has_global_storage
    //   [Bool]     is_extern_C
    //   [Bool]     is_local_var_decl
    //   [Bool]     is_function_or_method_var_decl
    //   [Bool]     is_static_data_member
    //   [Bool]     is_tentative_definition_now
    //   [Bool]     is_out_of_line
    //   [Bool]     is_file_var_decl
    //   [Bool]     is_direct_init
    //   [Bool]     is_knr_promoted
    //   [Bool]     has_default_arg
    //   [QualType] original_type
    // Outputs:
    //   [Decl] underlying_decl
    //   [Decl] canonical_decl
    //   [Decl] definition
    //   [Expr] any_initializer
    //   [Expr] init
    //   [Expr] default_arg
    //
    ParmVar:string {
      "This declares a parameter named “{name}”, with type “{type}”."
    }

    // LinkageSpecDecl
    // Inputs:
    //   [LinkageSpecDecl::LanguageIDs] language
    //
    LinkageSpec:string {
      "{language, select,"

      " c {This specifies C language linkage.}"

      " cxx {This specifies C++ language linkage.}"

      " other {}}"
    }

    // FileScopeAsmDecl
    // Outputs:
    //   [Expr] asm_string
    //
    FileScopeAsm:string {
      "This is used to include raw assembly."
    }


    //--------------------------------------------------------------------------
    // Stmt descriptions.
    //--------------------------------------------------------------------------
    
    // ArraySubscriptExpr
    // Inputs:
    //   [Bool]        is_lhs_base
    //   [GeneralType] base_type_general
    //   [GeneralType] idx_type_general
    // Values:
    //   rtv_of_this
    //   rtv_of_base
    //   rtv_of_idx
    // Outputs:
    //   [Expr] base
    //   [Expr] idx
    //
    ArraySubscriptExpr:string {
      "{is_lhs_base, select,"

      " true {{base_type_general, select,"
       " Pointer {"
        "This is an array subscript expression."
        " It consists of a @[base]base@[], which is a pointer, and an @[idx]index@[], which is an integer."
        " The result of this expression is the object that is “@[idx]index@[]” positions after the object that the @[base]base@[] points to."
        " That is, if the @[idx]index@[] is zero, the result of this expression will be the object that @[base]base@[] points to; if the @[idx]index@[] is one, the result of this expression will be object immediately following the object that @[base]base@[] points to; and so on."
        "\n\nRead more about pointers in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture17/]Lecture 17@[].}"
       " other {"
        "This is an array subscript expression."
        " It consists of a @[base]base@[], which is an array, and an @[idx]index@[], which is an integer."
        " The result of this expression is the element in the array that is “@[idx]index@[]” positions after the first element in the array."
        " That is, if the @[idx]index@[] is zero, the result of this expression will be the first element in the array; if the @[idx]index@[] is one, the result of this expression will be the second element in the array; and so on."
        "\n\nRead more about arrays in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture06/]Lecture 6@[].}}}"

      " false {{base_type_general, select,"
       " Pointer {"
        " This is an array subscript expression."
        " It consists of a @[base]base@[], which is a pointer, and an @[idx]index@[], which is an integer."
        " Typically the @[base]base@[] is on the left hand side, and the @[idx]index@[] is in square brackets, but this particular expression is using the opposite form."
        " The result of this expression is the object that is “@[idx]index@[]” positions after the object that the @[base]base@[] points to."
        " That is, if the @[idx]index@[] is zero, the result of this expression will be the object that @[base]base@[] points to; if the @[idx]index@[] is one, the result of this expression will be object immediately following the object that @[base]base@[] points to; and so on."
        "\n\nRead more about pointers in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture17/]Lecture 17@[].}"
       " other {"
        "This is an array subscript expression."
        " It consists of a @[base]base@[], which is an array, and an @[idx]index@[], which is an integer."
        " Typically the @[base]base@[] is on the left hand side, and the @[idx]index@[] is in square brackets, but this particular expression is using the opposite form."
        " The result of this expression is the element in the array that is “@[idx]index@[]” positions after the first element in the array."
        " That is, if the @[idx]index@[] is zero, the result of this expression will be the first element in the array; if the @[idx]index@[] is one, the result of this expression will be the second element in the array; and so on."
        "\n\nRead more about arrays in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture06/]Lecture 6@[].}}}"

      " other {}}"
    }

    // BreakStmt
    // Inputs:
    // Outputs:
    //
    BreakStmt:string {
      "This is a break statement."
      " It ends the execution of the first loop (“do”, “for”, or “while”) or “switch” statement that encloses it."
      "\n\nRead more about using break statements in loops in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture04/06.html]Lecture 4@[]."
    }

    // BinaryOperator
    // Inputs:
    //   [String]      opcode
    //   [GeneralType] type_general
    //   [GeneralType] lhs_type_general
    //   [GeneralType] rhs_type_general
    // Values:
    //   rtv_of_this
    //   rtv_of_lhs
    //   rtv_of_rhs
    // Outputs:
    //   [Expr] lhs
    //   [Expr] rhs
    //
    BinaryOperator:string {
      "{opcode, select,"

      // N1570 6.5.5
      " BO_Mul {{type_general, select,"
               " Integer {This is the multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}"
               " Floating {This is the multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}"
               " other {This is the multiplication operator. The result of this expression is the value of the @[lhs]left hand side@[] multiplied by the value of the @[rhs]right hand side@[].}}}"

      " BO_Div {{type_general, select,"
               " Integer {This is the division operator. In this case the division operator is being used to divide integers, so the result of the expression will be the result of dividing the value of @[lhs]left hand side@[] by the value of the @[rhs]right hand side@[], with any fractional part discarded. If you wish to find the value including the fractional part, then one or both of the values must be a floating point type.}"
               " Floating {This is the division operator. The result of this expression is the value of the @[lhs]left hand side@[] divided by the value of the @[rhs]right hand side@[].}"
               " other {This is the division operator. The result of this expression is the value of the @[lhs]left hand side@[] divided by the value of the @[rhs]right hand side@[].}}}"

      " BO_Rem {This is the remainder operator. It returns the remainder of dividing the @[lhs]left hand side@[] by the @[rhs]right hand side@[]. Since C99, the result is defined to have the same sign as the dividend.}"

      // N1570 6.5.6
      " BO_Add {{type_general, select,"
        " Pointer {"
          "{lhs_type_general, select,"
            " Pointer {"
              "This is the addition operator."
              " In this case it is being used to perform pointer arithmetic, because the @[lhs]left hand side@[] is a pointer."
              " If the @[lhs]left hand side@[] expression points to the i-th element of an array, then the result is a pointer to the (i+N)-th element, where N is the value of the @[rhs]right hand side@[] expression."
            "}"
            " other {"
              "This is the addition operator."
              " In this case it is being used to perform pointer arithmetic, because the @[rhs]right hand side@[] is a pointer."
              " If the @[rhs]right hand side@[] expression points to the i-th element of an array, then the result is a pointer to the (i+N)-th element, where N is the value of the @[lhs]left hand side@[] expression."
            "}}"
        "}"
        " other {"
          "This is the addition operator."
          " It returns the addition of the value of the @[lhs]left hand side@[] and the value of the @[rhs]right hand side@[]."
          "{has_rtv_of_lhs, select, true { The value of the left hand side is “{rtv_of_lhs}”.} other {}}"
          "{has_rtv_of_rhs, select, true { The value of the right hand side is “{rtv_of_rhs}”.} other {}}"
        "}}}"

      " BO_Sub {{type_general, select,"
        " Pointer {"
          "{lhs_type_general, select,"
            " Pointer {"
              "This is the subtraction operator."
              " In this case it is being used to perform pointer arithmetic, because the @[lhs]left hand side@[] is a pointer."
              " If the @[lhs]left hand side@[] expression points to the i-th element of an array, then the result is a pointer to the (i-N)-th element, where N is the value of the @[rhs]right hand side@[] expression."
            "}"
            " other {"
              "This is the subtraction operator."
              " In this case it is being used to perform pointer arithmetic, because the @[rhs]right hand side@[] is a pointer."
              " If the @[rhs]right hand side@[] expression points to the i-th element of an array, then the result is a pointer to the (i-N)-th element, where N is the value of the @[lhs]left hand side@[] expression."
            "}}"
        "}"
        " other {"
          "{lhs_type_general, select,"
            " Pointer {"
              "This is the subtraction operator."
              " In this case it is being used to find the difference between two pointer operands, both of which must point to elements of the same array."
              " If the @[lhs]left hand side@[] and @[rhs]right hand side@[] expressions point to, respectively, the i-th and j-th elements of the array, then the result of this operation is the value (i-j)."
            "}"
            " other {"
              "This is the subtraction operator."
              " It returns the result of subtracting the value of the @[rhs]right hand side@[] from the value of the @[lhs]left hand side@[]."
            "}"
          "}"
        "}"
      "}}"

      " BO_Shl {This is the “bitwise left shift” operator.}"

      " BO_Shr {This is the “bitwise right shift” operator.}"

      " BO_LT {This is the “less than” operator. If the value of the @[lhs]left hand side@[] is less than the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_GT {This is the “greater than” operator. If the value of the @[lhs]left hand side@[] is greater than the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_LE {This is the “less than or equal to” operator. If the value of the @[lhs]left hand side@[] is less than or equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_GE {This is the “greater than or equal to” operator. If the value of the @[lhs]left hand side@[] is greater than or equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_EQ {This is the “equal to” operator. If the value of the @[lhs]left hand side@[] is equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_NE {This is the “not equal to” operator. If the value of the @[lhs]left hand side@[] is not equal to the value of the @[rhs]right hand side@[], then it returns 1, otherwise it returns 0.}"

      " BO_And {This is the “bitwise AND” operator. If you wish to use the “logical AND” operator, it is &&.}"

      " BO_Xor {This is the “bitwise exclusive OR” operator. If you wish to perform exponentiation use the function “pow”.}"

      " BO_Or {This is the “bitwise inclusive OR” operator. If you wish to use the “logical inclusive OR” operator, it is ||.}"

      " BO_LAnd {"
        "This is the “logical AND” operator."
        " If both the value of the @[lhs]left hand side@[] and the value of the @[rhs]right hand side@[] are non-zero, then it returns 1, otherwise it returns 0."
        " The logical AND operator has “short-circuit evaluation”, which means that the @[lhs]left hand side@[] is always evaluated first, and if it evaluates to a zero value then the @[rhs]right hand side@[] is not evaluated, because the result of the operator is already known to be 0.}"

      " BO_LOr {"
        "This is the “logical OR” operator."
        " If either the value of the @[lhs]left hand side@[] or the value of the @[rhs]right hand side@[] are non-zero, then it returns 1, otherwise it returns 0."
        " The Logical OR operator has “short-circuit evaluation”, which means that the @[lhs]left hand side@[] is always evaluated first, and if it evaluates to a non-zero value then the @[rhs]right hand side@[] is not evaluated, because the result of the operator is already known to be 1.}"

      " BO_Assign {"
        "This is the assignment operator."
        " It stores the value of the @[rhs]right hand side@[] into the object designated by the @[lhs]left hand side@[]."
        " The result of the assignment operator is the new value of the object designated by the @[lhs]left hand side@[]."
      "}"

      " BO_Comma {"
        "This is the comma operator."
        " The comma operator evaluates the @[lhs]left hand side@[] expression and discards the result, then evaluates the @[rhs]right hand side@[] expression."
        " The value of the comma operator is the value of the @[rhs]right hand side@[] expression.}"

      " other {This is the binary operator {opcode}. It has a @[lhs]left hand side@[] and a @[rhs]right hand side@[]. The general type of this expression is {type_general}}}"
    }

    // CaseStmt
    // Inputs:
    //   [Bool] has_next_switch_case
    //   [Bool] has_sub_stmt
    //   [Bool] has_lhs
    //   [Bool] has_rhs
    // Values:
    //   rtv_of_lhs
    //   rtv_of_rhs
    // Outputs:
    //   [SwitchCase] next_switch_case
    //   [Stmt]       sub_stmt
    //   [Expr]       lhs
    //   [Expr]       rhs
    //
    CaseStmt:string {
      "This is a case statement."
      " If the @[lhs]left hand side@[] of this statement matches the value of the condition in the immediately enclosing switch statement, then the execution of the switch statement's body will begin with the @[rhs]right hand side@[] of this case."
      " If a break statement is encountered, then execution will jump to the end of the immediately enclosing switch statement."
      " If the end of this case is reached, then execution will proceed to the @[next_switch_case]next case@[], if one exists, otherwise it will proceed from the end of the immediately enclosing switch statement."
    }

    // CallExpr
    // Inputs:
    //   [Bool]        has_callee
    //   [Bool]        has_callee_decl
    //   [Bool]        has_direct_callee
    //   [Int]         num_args
    //   [GeneralType] general_type
    // Values:
    //   rtv_of_this
    // Outputs:
    //   [Expr] callee_expr
    //   [Decl] direct_callee_decl (when has_direct_callee == "true")
    //
    CallExpr:string {
      "{has_direct_callee, select,"
      " true {This is a function call."
             " It is formed by the @[callee_expr]name of a function@[],"
             " followed by a parenthesised list of argument expressions.}"
      " false {This is an indirect function call."
              " It is formed by @[callee_expr]an expression with a function pointer type@[],"
              " followed by a parenthesised list of argument expressions.}"
      " other {}}"

      "{num_args, plural,"
      " =0 { In this case there are no arguments, so the parentheses are empty.}"
      " =1 { In this case there is only one argument.}"
      " other { In this case there are {num_args} arguments.}"
      "}"

      "{general_type, select,"
      " Void { The called function has a void return type,"
             " so no value is produced by this call expression.}"
      " other { The value provided to the called function's return statement will be passed back from the function,"
              " and become the value produced by this call expression.}"
      "}"

      "\n\nRead more about function calls in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture05/]Lecture 5@[]."
    }

    // CharacterLiteral
    // Inputs:
    //   [CharacterKind] character_kind
    //   [Type]          type
    // Values:
    //   rtv_of_this
    // Outputs:
    //
    CharacterLiteral:string {
      "This is a character literal. It is a constant value of type “{type}”."
      "{has_rtv_of_this, select, true { The value is “{rtv_of_this}”.} false {} other {}}"
    }

    // CompoundAssignOperator
    // Inputs:
    //   [BinaryOperatorKind] opcode
    //   [GeneralTypeString]  type_general
    // Values:
    //   rtv_of_this
    //   rtv_of_lhs
    //   rtv_of_rhs
    // Outputs:
    //   [Expr] lhs
    //   [Expr] rhs
    //
    CompoundAssignOperator:string {
      "{opcode, select,"

      " BO_MulAssign {This is the multiplication compound assignment operator."
                     " It multiplies the value of the @[lhs]left hand side@[]"
                     " with the value of the @[rhs]right hand side@[],"
                     " then assigns the resulting value to the @[lhs]left hand side@[].}"

      " BO_DivAssign {This is the division compound assignment operator."
                     " It divides the value of the @[lhs]left hand side@[] by"
                     " the value of the @[rhs]right hand side@[], then assigns"
                     " the resulting value to the @[lhs]left hand side@[].}"

      " BO_RemAssign {This is the remainder compound  assignment operator."
                     " It calculates the remainder of dividing the value of the"
                     " @[lhs]left hand side@[] by the value of the"
                     " @[rhs]right hand side@[], then assigns the value of the"
                     " remainder to the @[lhs]left hand side@[].}"

      " BO_AddAssign {"
        "{type_general, select,"
          " Pointer {"
            "This is the addition compound assignment operator."
            " In this case the @[lhs]left operand@[] is a pointer, so the operator"
            " performs pointer arithmetic addition on the value of the @[lhs]left operand@[]"
            " and the value of the @[rhs]right operand@[], then stores the result"
            " in the object designated by the @[lhs]left operand@[]."
          "}"
          " other {"
            "This is the addition compound assignment operator."
            " It adds the value of the @[lhs]left hand side@[] and the"
            " value of the @[rhs]right hand side@[], then assigns the"
            " resulting value to the @[lhs]left hand side@[]."
          "}"
        "}"
      "}"

      " BO_SubAssign {"
        "{type_general, select,"
          " Pointer {"
            "This is the subtraction compound assignment operator."
            " In this case the @[lhs]left operand@[] is a pointer, so the operator"
            " performs pointer arithmetic subtraction on the value of the @[lhs]left operand@[]"
            " and the value of the @[rhs]right operand@[], then stores the result"
            " in the object designated by the @[lhs]left operand@[]."
          "}"
          " other {"
            "This is the subtraction compound assignment operator."
            " It subtracts the value of the @[rhs]right hand side@[]"
            " from the value of the @[lhs]left hand side@[], then"
            " assigns the resulting value to the @[lhs]left hand side@[]."
          "}"
        "}"
      "}"

      " BO_ShlAssign {This is the left-shift compound assignment operator.}"

      " BO_ShrAssign {This is the right-shift compound assignment operator.}"

      " BO_AndAssign {This is the bitwise AND compound assignment operator.}"

      " BO_XorAssign {This is the bitwise exclusive OR compound assignment operator.}"

      " BO_OrAssign {This is the bitwise inclusive OR compound assignment operator.}"

      " other {Unknown CompoundAssignOperator: {opcode}.}"
      "}"
    }

    // CompoundLiteralExpr
    // Inputs:
    //   [Type] type
    // Values:
    //   rtv_of_this
    //   rtv_of_init
    // Outputs:
    //   [Expr] init
    //
    CompoundLiteralExpr:string {
      "This is a compound literal."
      " It provides an unnamed object of type “{type}”, whose value is given by"
      " the @[init]initializer list@[]."

      "{has_rtv_of_this, select,"
      " true  { In this case the value is “{rtv_of_this}”.}"
      " other {}}"
    }

    // CompoundStmt
    // Inputs:
    //   [Int] size
    // Values:
    // Outputs:
    //
    CompoundStmt:string {
      "This is a compound statement."
      " It consists of a group of statements, each of which will be evaluated in order."
      " {size, plural,"
      " =0 {This compound statement is empty (it contains no statements).}"
      " =1 {This compound statement contains one statement.}"
      " other {This compound statement contains {size} statements.}}"
    }

    // ConditionalOperator
    // Inputs:
    // Values:
    // Outputs:
    //   [Expr] cond
    //   [Expr] true_expr
    //   [Expr] false_expr
    //
    ConditionalOperator:string {
      "This is the conditional operator."
      " The form of this operator is “@[cond]condition@[] ? @[true_expr]true-expression@[] : @[false_expr]false-expression@[]”."
      " If the @[cond]condition@[] evaluates to true (non-zero), then the @[true_expr]true-expression@[]"
      " is evaluated and the result of the conditional operator is the result of"
      " the @[true_expr]true-expression@[]. Otherwise the @[false_expr]false-expression@[]"
      " is evaluated and the result of the conditional operator is the result of"
      " the @[false_expr]false-expression@[]."
    }

    // ContinueStmt
    // Inputs:
    // Values:
    // Outputs:
    //
    ContinueStmt:string {
      "This is a continue statement."
      " It ends the execution of the current iteration of the first loop (“do”, “for”, or “while”) that encloses it."
      " If this is a “do” or “while” loop, then execution continues by evaluating the condition expression of the loop."
      " If this is a “for” loop, then execution continues by evaluating the increment expression, followed by the condition expression."
      "\n\nRead more about the continue statement in @[http://undergraduate.csse.uwa.edu.au/units/CITS1002/lectures/lecture04/06.html]Lecture 4@[]."
    }

    // CStyleCastExpr
    // Inputs:
    //   [String] cast_kind_name
    //   [Type]   type
    //   [String] type_as_written
    // Values:
    //   rtv_of_this
    //   rtv_of_sub_expr
    //   rtv_of_sub_expr_as_written
    // Outputs:
    //   [Expr] sub_expr
    //   [Expr] sub_expr_as_written
    //
    CStyleCastExpr:string {
      "This is an explicit cast expression."
      " It changes the type of the @[sub_expr_as_written]sub-expression@[] by “casting” it to a new type."
      " In this case the new type is “{type_as_written}”."
    }

    // DeclRefExpr
    // Inputs:
    //   [String] name
    //   [String] kind_general: "Var" | "Function" | "EnumConstant" | "Other"
    //   [Bool]   has_definition (when kind_general == "Var")
    //   [Bool]   has_body       (when kind_general == "Function")
    //   [String] init_val       (when kind_general == "EnumConstant")
    // Values:
    //   rtv_of_this
    // Outputs:
    //   [Decl] decl
    //   [Decl] found_decl
    //
    DeclRefExpr:string {
      "{kind_general, select,"
      " Var {This refers to the variable @[decl]“{name}”@[].}"
      " Function {This refers to the function @[decl]“{name}”@[].}"
      " EnumConstant {This refers to the enum constant @[decl]“{name}”@[].}"
      " other {This is a reference to the declaration @[decl]“{name}”@[].}}"
    }

    // DeclStmt
    // Inputs:
    //   [Bool] is_single_decl
    // Values:
    // Outputs:
    //   [Decl] single_decl (when is_single_decl == "true")
    //
    DeclStmt:string {
      "{is_single_decl, select,"
      " true  {This is a statement containing a @[single_decl]single declaration@[].}"
      " false {This is a statement containing a group of declarations.}"
      " other {}}"
    }

    // DefaultStmt
    // Inputs:
    //   [Bool] has_next_switch_case
    //   [Bool] has_sub_stmt
    // Values:
    // Outputs:
    //   [SwitchCase] next_switch_case
    //   [Stmt]       sub_stmt
    //
    DefaultStmt:string {
      "This is a default case."
      " It is associated with the immediately enclosing switch statement."
      " If the condition of the switch statement does not match any other case"
      " statement, then the execution of the switch will proceed to this"
      " default case. If a break statement is encountered, then execution will"
      " jump to the end of the switch statement. If the end of this case is"
      " reached, then execution will proceed to the"
      " @[next_switch_case]next case@[], if one exists, otherwise it will"
      " proceed from the end of the switch statement."
    }

    // DoStmt
    // Inputs:
    // Values:
    //   rtv_of_this
    //   rtv_of_cond
    // Outputs:
    //   [Expr] cond
    //   [Stmt] body
    //
    DoStmt:string {
      "This is a “do while” loop."
      " It has a @[body]body@[] and a @[cond]condition@[]."
      " Initially, the @[body]body@[] is evaluated."
      " After the @[body]body@[] is evaluated, the @[cond]condition@[] is evaluated."
      " If the result of the @[cond]condition@[] is true (non-zero),"
      " then execution transfers to the beginning of the loop:"
      " the @[body]body@[] is evaluated again, followed by the @[cond]condition@[]."
      " This continues until the @[cond]condition@[]'s result is false (zero)."
    }

    // FloatingLiteral
    // Inputs:
    // Values:
    // Outputs:
    //
    FloatingLiteral:string {
      "This is a floating point literal."
    }

    // ForStmt
    // Inputs:
    //   [Bool] has_init
    //   [Bool] has_cond
    //   [Bool] has_inc
    //   [Bool] has_condition_variable
    //   [Bool] has_body
    // Values:
    //   rtv_of_init
    //   rtv_of_cond
    //   rtv_of_inc
    // Outputs:
    //   [Stmt] init
    //   [Expr] cond
    //   [Expr] inc
    //   [Stmt] body
    //
    ForStmt:string {
      "This is a “for” loop."
      " It consists of an @[init]initialization expression@[],"
      " a @[cond]condition expression@[],"
      " an @[inc]increment expression@[],"
      " and a @[body]body@[]."
      " Any of these expressions may be empty."

      " The @[init]initialization expression@[] is evaluated once at the"
      " beginning of the for loop's evaluation."
      " A variable declared in the @[init]initialization expression@[]"
      " has a lifetime that extends to the for loop's conclusion."
      "{has_init, select, false { This for loop's initialization expression is empty.}"
                        " other {}}"

      " The @[cond]condition expression@[] is evaluated at the beginning of each iteration."
      " If the expression's result is false (zero), then the loop is exited and"
      " execution continues from the first statement following the loop."
      "{has_cond, select, false { This for loop's condition expression is empty,"
                                " so the loop will continue until it reaches a"
                                " “break” statement or a “return” statement.}"
                        " other {}}"

      " The @[inc]increment expression@[] is evaluated at the end of each"
      " iteration (regardless of whether the iteration was completed by"
      " reaching the end of the @[body]body@[] or by evaluating a “continue” statement)."
      "{has_inc, select, false { This for loop's increment expression is empty.}"
                       " other {}}"

      " The @[body]body@[] is evaluated during each iteration of the loop"
      " (after the @[cond]condition expression@[] has evaluated to true (non-zero),"
      " and before the @[inc]increment expression@[] is evaluated)."
      "{has_body, select, false { This for loop's body is empty.}"
                        " other {}}"
    }

    // GotoStmt
    // Inputs:
    // Values:
    // Outputs:
    //   [LabelDecl] label
    //
    GotoStmt:string {
      "This is a “goto” statement."
      " It transfers execution directly to the named @[label]label@[]."
      " There are many safety problems associated with using goto statements."
      " You should prefer to structure your code using if statements,"
      " switch statements, for loops, and while loops."
    }

    // IfStmt
    // Inputs:
    //   [Bool] has_condition_variable
    //   [Bool] has_else
    // Values:
    //   rtv_of_this
    //   rtv_of_cond
    // Outputs:
    //   [Expr] cond
    //   [Stmt] then
    //   [Stmt] else
    //
    IfStmt:string {
      "This is an if statement. "

      "{has_else, select, "
       "true {It consists of a @[cond]condition@[], a @[then]body@[], and an @[else]else@[]. }"
       "false {It consists of a @[cond]condition@[] and a @[then]body@[]. }"
       "other {}}"

      "{has_bool_rtv_of_cond, select, "
       "true {"
        "{bool_rtv_of_cond, select, "
         "true {"
          "{has_else, select, "
           "true {The @[cond]condition@[]'s result is not equal to zero,"
                 " so the @[then]body@[] is executed,"
                 " but the @[else]else section@[] is not executed.}"
           "false {The @[cond]condition@[]'s result is not equal to zero,"
                  " so the @[then]body@[] is executed.}"
           "other {}}}"
         "false {"
          "{has_else, select, "
           "true {The @[cond]condition@[]'s result is equal to zero,"
                 " so the @[then]body@[] is not executed,"
                 " but the @[else]else section@[] is executed.}"
           "false {The @[cond]condition@[]'s result is equal to zero,"
                  " so the @[then]body@[] is not executed.}"
           "other {}}}"
         "other {}}}"
       "false {"
        "{has_else, select, "
         "true {If the @[cond]condition@[]'s result does not equal zero,"
               " then the @[then]body@[] will be executed,"
               " otherwise the @[else]else section@[] will be executed.}"
         "false {If the @[cond]condition@[]'s result does not equal zero,"
                " then the @[then]body@[] will be executed.}"
         "other {}}}"
       "other {}}"
    }

    // ImaginaryLiteral
    // Inputs:
    //   [GeneralType] sub_expr_type_general
    // Values:
    // Outputs:
    //   [Expr] sub_expr
    //
    ImaginaryLiteral:string {
      "This is an imaginary {sub_expr_type_general} literal."
    }

    // ImplicitCastExpr
    // Inputs:
    //   [CastKind] cast_kind_name
    //   [Type]     type
    // Values:
    //   rtv_of_this
    //   rtv_of_sub_expr
    //   rtv_of_sub_expr_as_written
    // Outputs:
    //   [Expr] sub_expr
    //   [Expr] sub_expr_as_written
    //
    ImplicitCastExpr:string {
      "{cast_kind_name, select,"

       "LValueToRValue {This represents loading the value referenced by the"
                       " @[sub_expr_as_written]sub-expression@[] from memory.}"

       "ArrayToPointerDecay {This is an implicit conversion from the array"
                            " @[sub_expr_as_written]sub-expression@[],"
                            " to a pointer that points to the first element"
                            " in the array.}"

       "FunctionToPointerDecay {This is an implicit conversion from the function"
                               " designator @[sub_expr_as_written]sub-expression@[]"
                               " to a pointer to the designated function.}"

       "NullToPointer {This is the implicit conversion of the NULL pointer"
                      " constant to a NULL pointer of the appropriate type.}"

       "PointerToBoolean {This is an implicit pointer to boolean conversion."
                         " If the @[sub_expr_as_written]sub-expression@[] is"
                         " not equal to NULL then the result is true, otherwise"
                         " the result is false.}"

       "IntegralToBoolean {This is an implicit conversion from the integer type"
                          " @[sub_expr_as_written]sub-expression@[] to a boolean."
                          " If the @[sub_expr_as_written]sub-expression@[]'s"
                          " result is not equal to zero then the result is true,"
                          " otherwise the result is false.}"

       "FloatingToBoolean {This is an implicit conversion from the floating point type"
                          " @[sub_expr_as_written]sub-expression@[] to a boolean."
                          " If the @[sub_expr_as_written]sub-expression@[]'s"
                          " result is not equal to zero then the result is true,"
                          " otherwise the result is false.}"

       "other {"
        "This is an implicit cast expression."
        " It changes the type of the @[sub_expr_as_written]sub-expression@[] by"
        " “casting” it into an appropriate type, so that it can be stored in a"
        " variable, passed to a function, or used with an operator. In this"
        " case the new type is “{type}”."
       "}"
      "}"
    }

    // IntegerLiteral description.
    // Inputs:
    // Values:
    // Outputs:
    //
    IntegerLiteral:string {
      "This is an integer literal."
    }

    // LabelStmt
    // Inputs:
    //   [String] name
    //   [Bool]   has_decl
    //   [Bool]   has_sub_stmt
    // Values:
    // Outputs:
    //   [Decl] decl
    //   [Stmt] sub_stmt
    //
    LabelStmt:string {
      "This is a label statement."
      " It declares a label with the name “{name}”, which is followed by a"
      " @[sub_stmt]sub-statement@[]."
    }

    // MemberExpr
    // Inputs:
    //   [String] member_decl_name
    //   [Bool]   is_arrow
    // Values:
    // Outputs:
    //   [Expr] base
    //   [Decl] member_decl
    //
    MemberExpr:string {
      "{is_arrow, select,"
      " true {This expression returns the member object named “{member_decl_name}”"
             " in the object that is pointed to by the @[base]pointer that"
             " precedes the arrow@[].}"
      " false {This expression returns the member object named “{member_decl_name}”"
              " in the @[base]object@[] that precedes the dot.}"
      " other {}}"
    }

    // NullStmt description.
    // Inputs:
    // Values:
    // Outputs:
    //
    NullStmt:string {
      "This is a null statement."
      " It does nothing at execution time."
      " When a statement is required to appear, a null statement can be used to"
      " indicate that no operations should occur."
      " For example, it may be used to indicate that the body of a loop is empty."
    }

    // OffsetOfExpr
    // Inputs:
    // Values:
    // Outputs:
    //
    OffsetOfExpr:string {
      "This is an offsetof expression."
      " It finds the offset of the specified member (the second parameter) in"
      " the given struct type (the first parameter)."
    }

    // ParenExpr
    // Inputs:
    // Values:
    // Outputs:
    //   [Expr] sub_expr
    //
    ParenExpr:string {
      "This is a parenthesized expression."
      " It wraps the contained @[sub_expr]sub-expression@[]."
      " This can be used, for example, to ensure that mathematical operators"
      " are associated with the intended operands."
    }

    // PredefinedExpr
    //   A predefined identifier, e.g. __func__ [C99 6.4.2.2].
    // Inputs:
    // Values:
    // Outputs:
    //
    PredefinedExpr:string {
      "This is a predefined identifier."
    }

    // ReturnStmt
    // Inputs:
    //   [Bool] has_return_value
    // Values:
    //   rtv_of_this
    //   rtv_of_return_value
    // Outputs:
    //   [Expr] return_value
    //
    ReturnStmt:string {
      "This is a return statement."
      " It terminates execution of the enclosing function, returning control to"
      " the caller of this function."
      " If a value is returned, then it will be received at the site where this"
      " function was called."
      " If this is the main function, then the program will end."

      "{has_return_value, select,"
      " true  { This return statement @[return_value]returns a value@[].}"
      " false { This return statement does not return a value.}"
      " other {}}"

      "{has_rtv_of_return_value, select,"
      " true  { This return statement is returning the value “{rtv_of_return_value}”.}"
      " other {}}"
    }

    // StringLiteral
    // Inputs:
    //   [String]     string
    //   [Int]        byte_length
    //   [Int]        length
    //   [Int]        char_byte_width
    //   [StringKind] string_kind
    //   [Int]        num_concatenated
    // Values:
    // Outputs:
    //
    StringLiteral:string {
      "{string_kind, select,"
       " ASCII {This is an ASCII string literal.}"
       " Wide {This is a wide string literal.}"
       " UTF8 {This is a UTF-8 (Unicode) string literal.}"
       " UTF16 {This is a UTF-16 (Unicode) string literal.}"
       " UTF32 {This is a UTF-32 (Unicode) string literal.}"
       " other {}}"

       "{num_concatenated, plural,"
       " =0    {}"
       " =1    {}"
       " other { This string literal was concatenated from {num_concatenated}"
               " individual string literals.}}"
    }

    // SwitchStmt
    // Inputs:
    //   [Bool] has_condition_variable
    //   [Bool] has_cond
    //   [Bool] has_body
    //   [Bool] is_all_enum_cases_covered
    // Values:
    //   rtv_of_cond
    // Outputs:
    //   [Expr] cond
    //   [Stmt] body
    //
    SwitchStmt:string {
      "This is a switch statement."
      " It has a @[cond]condition expression@[] and a @[body]body@[]."
      " The body may contain “case” statements and optionally a single “default” statement."
      " If the value produced by the @[cond]condition expression@[] matches the"
      " value of one of the case statements, then execution will jump to that"
      " case statement. If the value does not match any case statement, and"
      " there is a default statement, then execution will jump to the default"
      " statement. Otherwise, execution will jump to the end of the"
      " @[body]body@[] (i.e. it will proceed from the first point immediately"
      " following the switch statement)."
    }

    // UnaryExprOrTypeTraitExpr
    // Inputs:
    //   [UnaryExprOrTypeTrait] kind
    //   [Bool]                 is_argument_type
    //   [QualType]             argument_type
    // Values:
    // Outputs:
    //   [Expr] argument_expr (if "is_argument_type" == "false")
    //
    UnaryExprOrTypeTraitExpr:string {
      "{kind, select,"

      " UETT_SizeOf {"
        "{is_argument_type, select,"
        " true {This is a sizeof operation, being used on the type {argument_type}."
               " This operation returns the size of the type, which is the number"
               " of bytes needed to store one object of this type.}"
        " false {This is a sizeof operation, being used on an"
                " @[argument_expr]expression@[], which has type {argument_type}."
                " This operation returns the size of the type, which is the"
                " number of bytes needed to store one object of this type.}"
        " other {}}}"

      " UETT_AlignOf {"
        "{is_argument_type, select,"
        " true {This is the alignof operation, being used on the type"
               " {argument_type}.}"
        " false {This is the alignof operation, being used on an"
                " @[argument_expr]expression@[], which has type {argument_type}.}"
        " other {}}}"

      " UETT_VecStep {This is vec_step (used in OpenCL).}"

      " other {}}"
    }

    // UnaryOperator
    // Inputs:
    //   [UnaryOperatorKind] opcode
    //   [Bool]              is_prefix
    //   [Bool]              is_postfix
    //   [Bool]              is_increment_op
    //   [Bool]              is_decrement_op
    //   [Bool]              is_increment_decrement_op
    //   [Bool]              is_arithmetic_op
    // Values:
    //   rtv_of_this
    //   rtv_of_sub_expr
    // Outputs:
    //   [Expr] sub_expr
    //
    UnaryOperator:string {
      "{opcode, select,"

      " UO_PostInc {"
        "This is a post-increment operation. It returns the current value of"
        " the object referenced by the @[sub_expr]sub-expression@[], and"
        " increments (adds 1 to) the value that is stored in that object.}"

      " UO_PostDec {"
        "This is a post-decrement operation. It returns the current value of"
        " the object referenced by the @[sub_expr]sub-expression@[], and"
        " decrements (subtracts 1 from) the value that is stored in that object.}"

      " UO_PreInc {"
        "This is a pre-increment operation. It increments (adds 1 to) the value"
        " that is stored in the object referenced by the"
        " @[sub_expr]sub-expression@[], and returns the new value.}"

      " UO_PreDec {"
        "This is a pre-decrement operation. It decrements (subtracts 1 from)"
        " the value that is stored in the object referenced by the"
        " @[sub_expr]sub-expression@[], and returns the new value.}"

      " UO_AddrOf {"
        "This is an address-of operation. It takes the address of the object"
        " that is referenced by the @[sub_expr]sub-expression@[], producing a"
        " pointer to that object.}"

      " UO_Deref {"
        "This is a dereference operation. It returns the object that is at the"
        " address that is referenced by the pointer type"
        " @[sub_expr]sub-expression@[].}"

      " UO_Plus {This is a unary plus operation.}"

      " UO_Minus {"
        "This is a unary minus operation, which returns the additive inverse of"
        " the value produced by the @[sub_expr]sub-expression@[] (i.e. the"
        " value of the @[sub_expr]sub-expression@[] subtracted from zero).}"

      " UO_Not {"
        "This is a bitwise NOT, or complement, operation. It inverts the value"
        " of each individual bit in the value produced by the"
        " @[sub_expr]sub-expression@[].}"

      " UO_LNot {"
        "This is a logical negation (NOT) operation. If the value of the"
        " @[sub_expr]sub-expression@[] is true (non-zero), then this operation"
        " returns a false (zero) value. If the value of the"
        " @[sub_expr]sub-expression@[] is false (zero), then this operation"
        " returns a true (non-zero) value.}"

      " UO_Real {This operation returns the real part of a complex number.}"

      " UO_Imag {This operation returns the imaginary part of a complex number.}"

      " UO_Extension {This is the extension marker.}"

      " other {}}"
    }

    // WhileStmt description
    // Inputs:
    //   [Bool] has_condition_variable
    //   [Bool] has_cond
    //   [Bool] has_body
    // Values:
    //   rtv_of_cond
    // Outputs:
    //   [DeclStmt] condition_variable
    //   [Expr]     cond
    //   [Stmt]     body
    //
    WhileStmt:string {
      "This is a while loop. It has a @[cond]condition expression@[] and a"
      " @[body]body@[]. At the beginning of the loop, the"
      " @[cond]condition expression@[] is evaluated."

      "{has_rtv_of_cond, select,"
      " true  { In this case it has evaluated to {rtv_of_cond}.}"
      " other {}}"

      " If this value is true (non-zero), then the loop's @[body]body@[] is"
      " executed. If the end of the @[body]body@[] is reached, or a continue"
      " statement is evaluated, then the iteration is complete and execution"
      " returns to the beginning of the loop (i.e. the"
      " @[cond]condition expression@[] is evaluated again). If the value"
      " produced by the @[cond]condition expression@[] is false (zero), then"
      " the loop is terminated and execution proceeds to the first statement"
      " following the end of the @[body]body@[]."
    }

    // InitListExpr
    // Inputs:
    //   [Type] type
    //   [Bool] is_string_literal_init
    //   [Bool] had_array_range_designator
    // Values:
    // Outputs:
    //   [FieldDecl] initialized_field_in_union
    //
    InitListExpr:string {
      "This is an initializer list."
      " It is used to initialize structs, unions, or arrays."
    }
  }
}
