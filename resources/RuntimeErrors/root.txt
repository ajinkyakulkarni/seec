root:table {
  // Contains textual descriptions of runtime errors.
  descriptions:table {
    // select MemoryAccess {read, write}
    // address
    // size
    MemoryUnowned:string {
      "{access_type, select, "
        "read {Attempt to read unowned memory at address {address} ({size} bytes).}"
        "write {Attempt to write unowned memory at address {address} ({size} bytes).}"
        "other {Attempt to {access_type} unowned memory at address {address} ({size} bytes).}"
      "}"
    }

    // address
    // size
    MemoryUninitialized:string {
      "Read uninitialized memory from address {address} ({size} bytes)."
    }

    // select MemoryAccess {read, write}
    // access address
    // access size
    // object
    // object address
    // object size
    MemoryOverflow:string {
      "Attempt to {access_type} memory at address {access_address} ({access_size} bytes) overflows object at address {object_address} ({object_size} bytes).}"
    }

    // dynamic memory function
    // address
    BadDynamicMemoryAddress:string {
      "{function, select, "
        "free {Bad address {address} given to free.}"
        "realloc {Bad address {address} given to realloc.}"
        "other {Bad address {address} given to function {function}.}"
      "}"
    }

    // function name
    // overlap address
    // overlap size
    OverlappingSourceDest:string {
      "Function {function} source and destination memory blocks overlap at address {address} ({size} bytes)."
    }

    // string function name
    // address of invalid string
    // index of the argument that held the pointer
    InvalidCString:string {
      "Address {address}, passed to parameter {parameter} of function {function}, does not refer to a C string."
    }
    
    // dummy
    DivideByZero:string {
      "Divide by zero!"
    }

    // dummy
    IntegerOverflow:string {
      "Integer overflow!"
    }

    // dummy
    IntegerUnderflow:string {
      "Integer underflow!"
    }

    // function
    // address
    // parameter
    PassPointerToUnowned:string {
      "Parameter {parameter} passed to function {function} points to unowned memory at address {address}."
    }

    // function
    // address
    // parameter
    PassPointerToUninitialized:string {
      "Parameter {parameter} passed to function {function} points to uninitialized memory at address {address}."
    }

    // function
    // access_address
    // access_size
    // accessible_size
    // object
    // object_address
    // object_size
    PassPointerToInsufficient:string {
      "Insufficient memory at destination of pointer passed to {function}. Needed {access_size} bytes and received {accessible_size}."
    }

    // function
    // parameter
    PassInvalidStream:string {
      "Parameter {parameter} passed to function {function} is not a valid FILE pointer."
    }

    // function
    // stream
    UseInvalidStream:string {
      "Call to function \"{function}\" would use standard stream \"{stream}\", which is closed. Perhaps the program previously closed this stream by calling fclose({stream})?"
    }

    // function
    // parameter
    // start
    FormatSpecifierParse:string {
      "Failed to parse format specifier starting at position {start} in the format string provided to function {function} (as parameter {parameter})."
    }

    // function
    // parameter
    // start
    // flag
    // end
    FormatSpecifierFlag:string {
      "Invalid flag \"{flag}\" supplied to format specifier starting at position {start} in the format string provided to function {function} (as parameter {parameter})."
    }

    // function
    // parameter
    // start
    // end
    FormatSpecifierWidthDenied:string {
      "In the format string provided to function {function} (as parameter {parameter}), a width was specified for the conversion specifier starting at position {start}, but this conversion specifier does not allow a width to be specified."
    }

    // function
    // parameter
    // start
    // end
    // width_parameter
    FormatSpecifierWidthArgType:string {
      "When calling function \"{function}\", in the format string provided (as parameter {parameter}), the conversion specifier starting at position {start} indicated that a width would be passed as an argument (this is indicated by the '*' character). However, the argument provided (as parameter {width_parameter}) was not of type \"int\", which it is required to be."
    }

    // function
    // parameter
    // start
    // end
    FormatSpecifierWidthMissing:string {
      "When calling function \"{function}\", in the format string provided (as parameter {parameter}), the conversion specifier starting at position {start} did not provide a maximum field width. It is possible for this to lead to a buffer overflow (if the conversion matches more characters than can fit into the destination buffer). For safety, provide a maximum field width (as an integer written directly after the \"%\" character that begins the conversion specifier)."
    }

    // function
    // parameter
    // start
    // end
    FormatSpecifierPrecisionDenied:string {
      "In the format string provided to function {function} (as parameter {parameter}), a precision was specified for the conversion specifier starting at position {start}, but this conversion specifier does not allow a precision to be specified."
    }

    // function
    // parameter
    // start
    // end
    // precision_parameter
    FormatSpecifierPrecisionArgType:string {
      "When calling function \"{function}\", in the format string provided (as parameter {parameter}), the conversion specifier starting at position {start} indicated that a precision would be passed as an argument (this is indicated by the '*' character following the precision character '.'). However, the argument provided (as parameter {precision_parameter}) was not of type \"int\", which it is required to be."
    }

    // function
    // parameter
    // start
    // end
    // length
    FormatSpecifierLengthDenied:string {
      "In the format string provided to function {function} (as parameter {parameter}), the length modifier \"{length}\" was used for the conversion specifier starting at position {start}, but this conversion specifier does not support this length modifier."
    }

    // function
    // parameter
    // start
    // end
    FormatSpecifierSuppressionDenied:string {
      "In the format string provided to function {function} (as parameter {parameter}), the assignment-suppressing character \"*\" was present in the conversion specifier starting at position {start}, but this conversion specifier does not support assignment suppression."
    }

    // function
    // format_index
    // specifier_start
    // specifier_end
    // specifier_length
    // argument
    // bytes_available
    // bytes_required
    //
    ScanFormattedStringOverflow:string {
      "An overflow occurred while matching the string conversion specifier at character {specifier_start} in the format string given to function {function}."
      " There {bytes_available, plural, =0 {were no bytes available} =1 {was one byte available} other {were {bytes_available} bytes available}}"
      " at the destination of the pointer given as argument {argument},"
      " but the matched string required {bytes_required, plural, =1 {one byte} other {{bytes_required} bytes}}."
      " To avoid potential overflows when using the various \"scan\" functions to match strings, one should always specify a \"maximum field width\" for the conversion."
      " The maximum field width specifies the maximum number of characters that will be used to match a conversion."
      " It is specified by placing an integer number, greater than zero, after the introductory \"%\" character."
      " For example, if we were reading into a buffer that could hold 20 characters, we would specify the maximum field width to be 19 like so: \"%19s\""
      " (note that the last character in the buffer is reserved for the terminating null character which will be placed at the end of the string by the scan function)."
    }

    // function
    // expected
    // received
    VarArgsSuperfluous:string {
      "Superfluous arguments passed to function {function}. Expected "
        "{expected, plural, =0 {no variadic arguments} =1 {{expected} variadic argument} other {{expected} variadic arguments}}"
        ", but received "
        "{received, plural, =0 {none.} other {only {received}.}}"
    }

    // function
    // expected
    // received
    VarArgsInsufficient:string {
      "Insufficient arguments passed to function {function}. Expected "
        "{expected, plural, =1 {{expected} variadic argument} other {{expected} variadic arguments}}"
        ", but received "
        "{received, plural, =0 {none.} other {only {received}.}}"
    }
  }
}
